# Динозаврик на STM32

## Постановка задачи

Сервер должен: принимать данные и управляющие команды от программы - клиента по локальной сети через подмножество протокола Modbus TCP; обеспечивать управление периферийным устройством USB-HID осуществляя запись и чтение данных в соответствии с принятыми от программы – клиента командами. 
Клиент должен: осуществлять взаимодействие с пользователем; подключаться к серверу в локальной сети и передавать ему на выполнение команды по протоколу Modbus TCP, или показывать состояние устройств ввода отладочного комплекта.

## ОПИСАНИЕ СТРУКТУРЫ ModBus TCP

Для общения клиента и сервера использовалась структура ModBus. Modbus — коммуникационный протокол, основан на архитектуре ведущий-ведомый.
Первое поле Transaction Identifier может быть любым числом, но главное, чтобы при отправке данных с сервера оно совпадало с отправленным клиентом. Поле Protocol Identifier всегда равно нулю по протоколу.
Поле Unit Identifier повторяется устройством Slave для однозначной идентификации устройства. Поле Function Code содержит число, которое нужно для того, чтобы сервер правильно отреагировал на запрос клиента.
В нашем случае код равен «0x03». Поле Data содержит данные, которые хочет передать пользователь.
В нашем случае структура с данными будет записана именно сюда при помощи функции memcpy, которая копируют память из одной области в другую.
Поле Length заполняется в последнюю очередь и отражает длину переданных данных в поле Data. Структура заполняется программно, пользователь может повлиять только на поле data.

![image](https://github.com/user-attachments/assets/0dc7a8f2-5df2-4e69-b607-07d3fe5afe08)

## Описание разработанного ПО клиента

Клиент реализован на базе языка С++. 
main.cpp – клиент, в котором реализована возможность выбора режима игры и скорости. Режим игры имеет 2 варианта: динозаврик бежит справа налево, либо слева направо. 
Для реализации клиентской части приложения создана структура struct Modbus, в которой определены поля: id транзакции, id протокола, длина, адрес устройства, функциональный код и данные. Используются 8 и 16-битовые целочисленные типы.

![image](https://github.com/user-attachments/assets/859e6fb8-6c47-4c5a-92ba-061dc7d55a1e)

Так же создана структура struct GameSettings, подразумевающая под собой выбор режима и скорости игры. Используются целочисленные типы.

![image](https://github.com/user-attachments/assets/e8a2a2d6-8f1d-4dbd-a319-28179ab61419)

Далее мы заполянем структуру, выделяем память под каждое поле. Добавляем возможность выбора режима игры и скорости. Так же по стандарту создан массив для отправки, в который пакуются данные. Реализована инициазиция DLL, создан сокет. 

![image](https://github.com/user-attachments/assets/ce98343d-6ec5-48ed-a3db-c7ace831d731)

![image](https://github.com/user-attachments/assets/f3f13a2b-b6fd-4a25-babb-f4ca338bc027)

## Разработка ПО сервера

Для обеспечения сетевых коммуникаций используются сокеты. Сокет - это конечная точка сетевых коммуникаций. В Internet домене сокет - это комбинация IP адреса и номера порта. В нашем случае использовался 502 порт. 
В программе был создан и привязан сокет, создан и заполнен пакет ModBus, далее пакет упаковывался в массив и отправлялся на сервер.
Сервер был реализован на языке C++, ведь библиотека HidApi была совместима с этим языком. Работа сервера также можно разделить на две части: получение пакета Modbus и отправка данных на плату.
UsbHidVS.sln – серверная часть приложения. Реализован usbhid. На него приходят запросы с клиента и передаются на плату. 
Аналогично клиентской части, мы создаем те же структуры, выделяем под них место, заполняем и получаем результат. Подключение библиотеки ws2_32.lib обязательно – приложения, использующие Winsock, должны быть связаны с файлом библиотеки ws2_32.lib.

![image](https://github.com/user-attachments/assets/5e546ccc-03f1-4a3a-b168-ede586e6154d)

Кроме этого, в данной части программы реализована отрисовка динозаврика с помощью матрицы 21х21, столбцы, через которые динозаврик прыгает, а так же остальная логика игры, а именно прыжки, возрождение, падение. Здесь так же инициализируем DLL, создаем и привязываем сокет, ожидаем и получаем клиентский запрос (от клиентской части программы), дальше массив и упаковка для отправки. Все аналогично клиентской части.

![image](https://github.com/user-attachments/assets/7a8d5b55-67a5-4e54-b815-4f19285ce594)

## Реализация взаимодействия с устройством

Для работы с платой использовалось ПО Keil uVision, которое позволяет загружать и менять драйвера для управления платой.
KEIL_USB_HID – проект keil, в котором произведено изменение usbd_custom_hid_if.c.
В типе команды 0х02 реализован вывод счетчика – изначально ставится курсор, а затем цифра выводится на экран. 
В типе команды 0х04 передается x и y, реализована отрисовка пикселя.

![image](https://github.com/user-attachments/assets/cea7a8cf-8cfc-427d-8d44-45f2956c269e)

Отправка данных на плату производится с помощью функции «hid_open» - она устанавливает связь с платой. После получения данных применяется функция «hid_send_feature_report», которая позволяет отправить массив данных на плату, которая обработает его в зависимости от первого байта массива. В нашем случае первый бит равен «0x02». Если связь с платой разорвана, то в консоль будет выведена ошибка.
После отправки данных обратно клиенту вернется сообщение, что данные успешно получены или сообщение об ошибке, если функциональный код другой.
Также стоит сказать, что сервер с данными работу не ведет, а его задача состоит в том, чтобы эти данные правильно передать от клиента на плату.

## Демонстрация работы программы

![image](https://github.com/user-attachments/assets/f5fc2b82-5cb8-4997-99f2-ac065b978840)

![image](https://github.com/user-attachments/assets/e903040b-9c62-4fed-9c6d-ec55aefba3c9)

![image](https://github.com/user-attachments/assets/6ac7dfe0-8a72-4dbb-b37e-7ead340df481)
